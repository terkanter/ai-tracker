// This file is auto-generated by @hey-api/openapi-ts

import {
  type Options,
  prometheusControllerIndex,
  healthControllerCheck,
  userControllerGetCurrentUser,
  userControllerUpdateUserProfile,
  userControllerFindAllUsers,
  userControllerDeleteUser,
  userControllerFindUser,
  comicControllerFindAllComics,
  comicControllerCreateComic,
  comicControllerFindComicBySlug,
  comicControllerDeleteComic,
  comicControllerUpdateComic,
  comicControllerGetAllGenres,
  comicControllerCreateGenre,
  comicControllerDeleteGenre,
  comicControllerUpdateGenre,
  comicControllerGetAllTags,
  comicControllerCreateTag,
  comicControllerDeleteTag,
  comicControllerUpdateTag,
  comicControllerGetAllRatings,
  comicControllerCreateRating,
  comicControllerDeleteRating,
  comicControllerUpdateRating,
  comicControllerGetAllCountries,
  comicControllerCreateCountry,
  comicControllerDeleteCountry,
  comicControllerUpdateCountry,
  comicControllerGetAllStatuses,
  comicControllerCreateStatus,
  comicControllerDeleteStatus,
  comicControllerUpdateStatus,
  chapterControllerFindAllChapters,
  chapterControllerCreateChapter,
  chapterControllerFindChapterBySlug,
  chapterControllerDeleteChapter,
  chapterControllerUpdateChapter,
  userTitleStateControllerFindAllUserTitleStates,
  userTitleStateControllerCreateUserTitleState,
  userTitleStateControllerGetUserBookmarks,
  userTitleStateControllerDeleteUserTitleState,
  userTitleStateControllerFindUserTitleState,
  userTitleStateControllerUpdateUserTitleState,
  userTitleStateControllerGetUserTitleState,
  userTitleStateControllerUpdateReadingProgress,
} from "../sdk.gen.js";
import {
  queryOptions,
  type UseMutationOptions,
  infiniteQueryOptions,
  type InfiniteData,
} from "@tanstack/react-query";
import type {
  PrometheusControllerIndexData,
  HealthControllerCheckData,
  UserControllerGetCurrentUserData,
  UserControllerUpdateUserProfileData,
  UserControllerUpdateUserProfileError,
  UserControllerUpdateUserProfileResponse,
  UserControllerFindAllUsersData,
  UserControllerFindAllUsersError,
  UserControllerFindAllUsersResponse,
  UserControllerDeleteUserData,
  UserControllerDeleteUserError,
  UserControllerFindUserData,
  ComicControllerFindAllComicsData,
  ComicControllerFindAllComicsError,
  ComicControllerFindAllComicsResponse,
  ComicControllerCreateComicData,
  ComicControllerCreateComicError,
  ComicControllerCreateComicResponse,
  ComicControllerFindComicBySlugData,
  ComicControllerDeleteComicData,
  ComicControllerDeleteComicError,
  ComicControllerUpdateComicData,
  ComicControllerUpdateComicError,
  ComicControllerUpdateComicResponse,
  ComicControllerGetAllGenresData,
  ComicControllerCreateGenreData,
  ComicControllerCreateGenreError,
  ComicControllerCreateGenreResponse,
  ComicControllerDeleteGenreData,
  ComicControllerDeleteGenreError,
  ComicControllerUpdateGenreData,
  ComicControllerUpdateGenreError,
  ComicControllerUpdateGenreResponse,
  ComicControllerGetAllTagsData,
  ComicControllerCreateTagData,
  ComicControllerCreateTagError,
  ComicControllerCreateTagResponse,
  ComicControllerDeleteTagData,
  ComicControllerDeleteTagError,
  ComicControllerUpdateTagData,
  ComicControllerUpdateTagError,
  ComicControllerUpdateTagResponse,
  ComicControllerGetAllRatingsData,
  ComicControllerCreateRatingData,
  ComicControllerCreateRatingError,
  ComicControllerCreateRatingResponse,
  ComicControllerDeleteRatingData,
  ComicControllerDeleteRatingError,
  ComicControllerUpdateRatingData,
  ComicControllerUpdateRatingError,
  ComicControllerUpdateRatingResponse,
  ComicControllerGetAllCountriesData,
  ComicControllerCreateCountryData,
  ComicControllerCreateCountryError,
  ComicControllerDeleteCountryData,
  ComicControllerDeleteCountryError,
  ComicControllerUpdateCountryData,
  ComicControllerUpdateCountryError,
  ComicControllerGetAllStatusesData,
  ComicControllerCreateStatusData,
  ComicControllerCreateStatusError,
  ComicControllerCreateStatusResponse,
  ComicControllerDeleteStatusData,
  ComicControllerDeleteStatusError,
  ComicControllerUpdateStatusData,
  ComicControllerUpdateStatusError,
  ComicControllerUpdateStatusResponse,
  ChapterControllerFindAllChaptersData,
  ChapterControllerFindAllChaptersError,
  ChapterControllerFindAllChaptersResponse,
  ChapterControllerCreateChapterData,
  ChapterControllerCreateChapterError,
  ChapterControllerCreateChapterResponse,
  ChapterControllerFindChapterBySlugData,
  ChapterControllerDeleteChapterData,
  ChapterControllerDeleteChapterError,
  ChapterControllerUpdateChapterData,
  ChapterControllerUpdateChapterError,
  ChapterControllerUpdateChapterResponse,
  UserTitleStateControllerFindAllUserTitleStatesData,
  UserTitleStateControllerCreateUserTitleStateData,
  UserTitleStateControllerCreateUserTitleStateError,
  UserTitleStateControllerCreateUserTitleStateResponse,
  UserTitleStateControllerGetUserBookmarksData,
  UserTitleStateControllerDeleteUserTitleStateData,
  UserTitleStateControllerDeleteUserTitleStateError,
  UserTitleStateControllerFindUserTitleStateData,
  UserTitleStateControllerUpdateUserTitleStateData,
  UserTitleStateControllerUpdateUserTitleStateError,
  UserTitleStateControllerUpdateUserTitleStateResponse,
  UserTitleStateControllerGetUserTitleStateData,
  UserTitleStateControllerUpdateReadingProgressData,
  UserTitleStateControllerUpdateReadingProgressError,
  UserTitleStateControllerUpdateReadingProgressResponse,
} from "../types.gen.js";
import { client as _heyApiClient } from "../client.gen.js";

export type QueryKey<TOptions extends Options> = [
  Pick<TOptions, "baseUrl" | "body" | "headers" | "path" | "query"> & {
    _id: string;
    _infinite?: boolean;
  },
];

const createQueryKey = <TOptions extends Options>(
  id: string,
  options?: TOptions,
  infinite?: boolean,
): [QueryKey<TOptions>[0]] => {
  const params: QueryKey<TOptions>[0] = {
    _id: id,
    baseUrl: (options?.client ?? _heyApiClient).getConfig().baseUrl,
  } as QueryKey<TOptions>[0];
  if (infinite) {
    params._infinite = infinite;
  }
  if (options?.body) {
    params.body = options.body;
  }
  if (options?.headers) {
    params.headers = options.headers;
  }
  if (options?.path) {
    params.path = options.path;
  }
  if (options?.query) {
    params.query = options.query;
  }
  return [params];
};

export const prometheusControllerIndexQueryKey = (
  options?: Options<PrometheusControllerIndexData>,
) => createQueryKey("prometheusControllerIndex", options);

export const prometheusControllerIndexOptions = (
  options?: Options<PrometheusControllerIndexData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await prometheusControllerIndex({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: prometheusControllerIndexQueryKey(options),
  });
};

export const healthControllerCheckQueryKey = (
  options?: Options<HealthControllerCheckData>,
) => createQueryKey("healthControllerCheck", options);

/**
 * Health check
 */
export const healthControllerCheckOptions = (
  options?: Options<HealthControllerCheckData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await healthControllerCheck({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: healthControllerCheckQueryKey(options),
  });
};

export const userControllerGetCurrentUserQueryKey = (
  options?: Options<UserControllerGetCurrentUserData>,
) => createQueryKey("userControllerGetCurrentUser", options);

/**
 * Get current user
 */
export const userControllerGetCurrentUserOptions = (
  options?: Options<UserControllerGetCurrentUserData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await userControllerGetCurrentUser({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: userControllerGetCurrentUserQueryKey(options),
  });
};

/**
 * Update user's profile
 */
export const userControllerUpdateUserProfileMutation = (
  options?: Partial<Options<UserControllerUpdateUserProfileData>>,
): UseMutationOptions<
  UserControllerUpdateUserProfileResponse,
  UserControllerUpdateUserProfileError,
  Options<UserControllerUpdateUserProfileData>
> => {
  const mutationOptions: UseMutationOptions<
    UserControllerUpdateUserProfileResponse,
    UserControllerUpdateUserProfileError,
    Options<UserControllerUpdateUserProfileData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await userControllerUpdateUserProfile({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const userControllerFindAllUsersQueryKey = (
  options?: Options<UserControllerFindAllUsersData>,
) => createQueryKey("userControllerFindAllUsers", options);

/**
 * List users.
 */
export const userControllerFindAllUsersOptions = (
  options?: Options<UserControllerFindAllUsersData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await userControllerFindAllUsers({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: userControllerFindAllUsersQueryKey(options),
  });
};

const createInfiniteParams = <
  K extends Pick<QueryKey<Options>[0], "body" | "headers" | "path" | "query">,
>(
  queryKey: QueryKey<Options>,
  page: K,
) => {
  const params = queryKey[0];
  if (page.body) {
    params.body = {
      ...(queryKey[0].body as any),
      ...(page.body as any),
    };
  }
  if (page.headers) {
    params.headers = {
      ...queryKey[0].headers,
      ...page.headers,
    };
  }
  if (page.path) {
    params.path = {
      ...(queryKey[0].path as any),
      ...(page.path as any),
    };
  }
  if (page.query) {
    params.query = {
      ...(queryKey[0].query as any),
      ...(page.query as any),
    };
  }
  return params as unknown as typeof page;
};

export const userControllerFindAllUsersInfiniteQueryKey = (
  options?: Options<UserControllerFindAllUsersData>,
): QueryKey<Options<UserControllerFindAllUsersData>> =>
  createQueryKey("userControllerFindAllUsers", options, true);

/**
 * List users.
 */
export const userControllerFindAllUsersInfiniteOptions = (
  options?: Options<UserControllerFindAllUsersData>,
) => {
  return infiniteQueryOptions<
    UserControllerFindAllUsersResponse,
    UserControllerFindAllUsersError,
    InfiniteData<UserControllerFindAllUsersResponse>,
    QueryKey<Options<UserControllerFindAllUsersData>>,
    | number
    | Pick<
        QueryKey<Options<UserControllerFindAllUsersData>>[0],
        "body" | "headers" | "path" | "query"
      >
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<UserControllerFindAllUsersData>>[0],
          "body" | "headers" | "path" | "query"
        > =
          typeof pageParam === "object"
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await userControllerFindAllUsers({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: userControllerFindAllUsersInfiniteQueryKey(options),
    },
  );
};

/**
 * Delete a user
 */
export const userControllerDeleteUserMutation = (
  options?: Partial<Options<UserControllerDeleteUserData>>,
): UseMutationOptions<
  unknown,
  UserControllerDeleteUserError,
  Options<UserControllerDeleteUserData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    UserControllerDeleteUserError,
    Options<UserControllerDeleteUserData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await userControllerDeleteUser({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const userControllerFindUserQueryKey = (
  options: Options<UserControllerFindUserData>,
) => createQueryKey("userControllerFindUser", options);

/**
 * Find user by id
 */
export const userControllerFindUserOptions = (
  options: Options<UserControllerFindUserData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await userControllerFindUser({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: userControllerFindUserQueryKey(options),
  });
};

export const comicControllerFindAllComicsQueryKey = (
  options?: Options<ComicControllerFindAllComicsData>,
) => createQueryKey("comicControllerFindAllComics", options);

/**
 * List comics with offset pagination
 */
export const comicControllerFindAllComicsOptions = (
  options?: Options<ComicControllerFindAllComicsData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await comicControllerFindAllComics({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: comicControllerFindAllComicsQueryKey(options),
  });
};

export const comicControllerFindAllComicsInfiniteQueryKey = (
  options?: Options<ComicControllerFindAllComicsData>,
): QueryKey<Options<ComicControllerFindAllComicsData>> =>
  createQueryKey("comicControllerFindAllComics", options, true);

/**
 * List comics with offset pagination
 */
export const comicControllerFindAllComicsInfiniteOptions = (
  options?: Options<ComicControllerFindAllComicsData>,
) => {
  return infiniteQueryOptions<
    ComicControllerFindAllComicsResponse,
    ComicControllerFindAllComicsError,
    InfiniteData<ComicControllerFindAllComicsResponse>,
    QueryKey<Options<ComicControllerFindAllComicsData>>,
    | number
    | Pick<
        QueryKey<Options<ComicControllerFindAllComicsData>>[0],
        "body" | "headers" | "path" | "query"
      >
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<ComicControllerFindAllComicsData>>[0],
          "body" | "headers" | "path" | "query"
        > =
          typeof pageParam === "object"
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await comicControllerFindAllComics({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: comicControllerFindAllComicsInfiniteQueryKey(options),
    },
  );
};

export const comicControllerCreateComicQueryKey = (
  options: Options<ComicControllerCreateComicData>,
) => createQueryKey("comicControllerCreateComic", options);

/**
 * Create a new comic
 */
export const comicControllerCreateComicOptions = (
  options: Options<ComicControllerCreateComicData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await comicControllerCreateComic({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: comicControllerCreateComicQueryKey(options),
  });
};

/**
 * Create a new comic
 */
export const comicControllerCreateComicMutation = (
  options?: Partial<Options<ComicControllerCreateComicData>>,
): UseMutationOptions<
  ComicControllerCreateComicResponse,
  ComicControllerCreateComicError,
  Options<ComicControllerCreateComicData>
> => {
  const mutationOptions: UseMutationOptions<
    ComicControllerCreateComicResponse,
    ComicControllerCreateComicError,
    Options<ComicControllerCreateComicData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await comicControllerCreateComic({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const comicControllerFindComicBySlugQueryKey = (
  options: Options<ComicControllerFindComicBySlugData>,
) => createQueryKey("comicControllerFindComicBySlug", options);

/**
 * Find comic by slug
 */
export const comicControllerFindComicBySlugOptions = (
  options: Options<ComicControllerFindComicBySlugData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await comicControllerFindComicBySlug({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: comicControllerFindComicBySlugQueryKey(options),
  });
};

/**
 * Delete a comic
 */
export const comicControllerDeleteComicMutation = (
  options?: Partial<Options<ComicControllerDeleteComicData>>,
): UseMutationOptions<
  unknown,
  ComicControllerDeleteComicError,
  Options<ComicControllerDeleteComicData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    ComicControllerDeleteComicError,
    Options<ComicControllerDeleteComicData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await comicControllerDeleteComic({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Update comic
 */
export const comicControllerUpdateComicMutation = (
  options?: Partial<Options<ComicControllerUpdateComicData>>,
): UseMutationOptions<
  ComicControllerUpdateComicResponse,
  ComicControllerUpdateComicError,
  Options<ComicControllerUpdateComicData>
> => {
  const mutationOptions: UseMutationOptions<
    ComicControllerUpdateComicResponse,
    ComicControllerUpdateComicError,
    Options<ComicControllerUpdateComicData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await comicControllerUpdateComic({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const comicControllerGetAllGenresQueryKey = (
  options?: Options<ComicControllerGetAllGenresData>,
) => createQueryKey("comicControllerGetAllGenres", options);

/**
 * List all genres
 */
export const comicControllerGetAllGenresOptions = (
  options?: Options<ComicControllerGetAllGenresData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await comicControllerGetAllGenres({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: comicControllerGetAllGenresQueryKey(options),
  });
};

export const comicControllerCreateGenreQueryKey = (
  options: Options<ComicControllerCreateGenreData>,
) => createQueryKey("comicControllerCreateGenre", options);

/**
 * Create a new genre
 */
export const comicControllerCreateGenreOptions = (
  options: Options<ComicControllerCreateGenreData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await comicControllerCreateGenre({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: comicControllerCreateGenreQueryKey(options),
  });
};

/**
 * Create a new genre
 */
export const comicControllerCreateGenreMutation = (
  options?: Partial<Options<ComicControllerCreateGenreData>>,
): UseMutationOptions<
  ComicControllerCreateGenreResponse,
  ComicControllerCreateGenreError,
  Options<ComicControllerCreateGenreData>
> => {
  const mutationOptions: UseMutationOptions<
    ComicControllerCreateGenreResponse,
    ComicControllerCreateGenreError,
    Options<ComicControllerCreateGenreData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await comicControllerCreateGenre({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Delete a genre
 */
export const comicControllerDeleteGenreMutation = (
  options?: Partial<Options<ComicControllerDeleteGenreData>>,
): UseMutationOptions<
  unknown,
  ComicControllerDeleteGenreError,
  Options<ComicControllerDeleteGenreData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    ComicControllerDeleteGenreError,
    Options<ComicControllerDeleteGenreData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await comicControllerDeleteGenre({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Update genre
 */
export const comicControllerUpdateGenreMutation = (
  options?: Partial<Options<ComicControllerUpdateGenreData>>,
): UseMutationOptions<
  ComicControllerUpdateGenreResponse,
  ComicControllerUpdateGenreError,
  Options<ComicControllerUpdateGenreData>
> => {
  const mutationOptions: UseMutationOptions<
    ComicControllerUpdateGenreResponse,
    ComicControllerUpdateGenreError,
    Options<ComicControllerUpdateGenreData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await comicControllerUpdateGenre({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const comicControllerGetAllTagsQueryKey = (
  options?: Options<ComicControllerGetAllTagsData>,
) => createQueryKey("comicControllerGetAllTags", options);

/**
 * List all tags
 */
export const comicControllerGetAllTagsOptions = (
  options?: Options<ComicControllerGetAllTagsData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await comicControllerGetAllTags({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: comicControllerGetAllTagsQueryKey(options),
  });
};

export const comicControllerCreateTagQueryKey = (
  options: Options<ComicControllerCreateTagData>,
) => createQueryKey("comicControllerCreateTag", options);

/**
 * Create a new tag
 */
export const comicControllerCreateTagOptions = (
  options: Options<ComicControllerCreateTagData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await comicControllerCreateTag({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: comicControllerCreateTagQueryKey(options),
  });
};

/**
 * Create a new tag
 */
export const comicControllerCreateTagMutation = (
  options?: Partial<Options<ComicControllerCreateTagData>>,
): UseMutationOptions<
  ComicControllerCreateTagResponse,
  ComicControllerCreateTagError,
  Options<ComicControllerCreateTagData>
> => {
  const mutationOptions: UseMutationOptions<
    ComicControllerCreateTagResponse,
    ComicControllerCreateTagError,
    Options<ComicControllerCreateTagData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await comicControllerCreateTag({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Delete a tag
 */
export const comicControllerDeleteTagMutation = (
  options?: Partial<Options<ComicControllerDeleteTagData>>,
): UseMutationOptions<
  unknown,
  ComicControllerDeleteTagError,
  Options<ComicControllerDeleteTagData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    ComicControllerDeleteTagError,
    Options<ComicControllerDeleteTagData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await comicControllerDeleteTag({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Update tag
 */
export const comicControllerUpdateTagMutation = (
  options?: Partial<Options<ComicControllerUpdateTagData>>,
): UseMutationOptions<
  ComicControllerUpdateTagResponse,
  ComicControllerUpdateTagError,
  Options<ComicControllerUpdateTagData>
> => {
  const mutationOptions: UseMutationOptions<
    ComicControllerUpdateTagResponse,
    ComicControllerUpdateTagError,
    Options<ComicControllerUpdateTagData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await comicControllerUpdateTag({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const comicControllerGetAllRatingsQueryKey = (
  options?: Options<ComicControllerGetAllRatingsData>,
) => createQueryKey("comicControllerGetAllRatings", options);

/**
 * List all ratings
 */
export const comicControllerGetAllRatingsOptions = (
  options?: Options<ComicControllerGetAllRatingsData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await comicControllerGetAllRatings({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: comicControllerGetAllRatingsQueryKey(options),
  });
};

export const comicControllerCreateRatingQueryKey = (
  options: Options<ComicControllerCreateRatingData>,
) => createQueryKey("comicControllerCreateRating", options);

/**
 * Create a new rating
 */
export const comicControllerCreateRatingOptions = (
  options: Options<ComicControllerCreateRatingData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await comicControllerCreateRating({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: comicControllerCreateRatingQueryKey(options),
  });
};

/**
 * Create a new rating
 */
export const comicControllerCreateRatingMutation = (
  options?: Partial<Options<ComicControllerCreateRatingData>>,
): UseMutationOptions<
  ComicControllerCreateRatingResponse,
  ComicControllerCreateRatingError,
  Options<ComicControllerCreateRatingData>
> => {
  const mutationOptions: UseMutationOptions<
    ComicControllerCreateRatingResponse,
    ComicControllerCreateRatingError,
    Options<ComicControllerCreateRatingData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await comicControllerCreateRating({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Delete a rating
 */
export const comicControllerDeleteRatingMutation = (
  options?: Partial<Options<ComicControllerDeleteRatingData>>,
): UseMutationOptions<
  unknown,
  ComicControllerDeleteRatingError,
  Options<ComicControllerDeleteRatingData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    ComicControllerDeleteRatingError,
    Options<ComicControllerDeleteRatingData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await comicControllerDeleteRating({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Update rating
 */
export const comicControllerUpdateRatingMutation = (
  options?: Partial<Options<ComicControllerUpdateRatingData>>,
): UseMutationOptions<
  ComicControllerUpdateRatingResponse,
  ComicControllerUpdateRatingError,
  Options<ComicControllerUpdateRatingData>
> => {
  const mutationOptions: UseMutationOptions<
    ComicControllerUpdateRatingResponse,
    ComicControllerUpdateRatingError,
    Options<ComicControllerUpdateRatingData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await comicControllerUpdateRating({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const comicControllerGetAllCountriesQueryKey = (
  options?: Options<ComicControllerGetAllCountriesData>,
) => createQueryKey("comicControllerGetAllCountries", options);

/**
 * List all countries
 */
export const comicControllerGetAllCountriesOptions = (
  options?: Options<ComicControllerGetAllCountriesData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await comicControllerGetAllCountries({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: comicControllerGetAllCountriesQueryKey(options),
  });
};

export const comicControllerCreateCountryQueryKey = (
  options?: Options<ComicControllerCreateCountryData>,
) => createQueryKey("comicControllerCreateCountry", options);

/**
 * Create a new country
 */
export const comicControllerCreateCountryOptions = (
  options?: Options<ComicControllerCreateCountryData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await comicControllerCreateCountry({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: comicControllerCreateCountryQueryKey(options),
  });
};

/**
 * Create a new country
 */
export const comicControllerCreateCountryMutation = (
  options?: Partial<Options<ComicControllerCreateCountryData>>,
): UseMutationOptions<
  unknown,
  ComicControllerCreateCountryError,
  Options<ComicControllerCreateCountryData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    ComicControllerCreateCountryError,
    Options<ComicControllerCreateCountryData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await comicControllerCreateCountry({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Delete a country
 */
export const comicControllerDeleteCountryMutation = (
  options?: Partial<Options<ComicControllerDeleteCountryData>>,
): UseMutationOptions<
  unknown,
  ComicControllerDeleteCountryError,
  Options<ComicControllerDeleteCountryData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    ComicControllerDeleteCountryError,
    Options<ComicControllerDeleteCountryData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await comicControllerDeleteCountry({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Update country
 */
export const comicControllerUpdateCountryMutation = (
  options?: Partial<Options<ComicControllerUpdateCountryData>>,
): UseMutationOptions<
  unknown,
  ComicControllerUpdateCountryError,
  Options<ComicControllerUpdateCountryData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    ComicControllerUpdateCountryError,
    Options<ComicControllerUpdateCountryData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await comicControllerUpdateCountry({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const comicControllerGetAllStatusesQueryKey = (
  options?: Options<ComicControllerGetAllStatusesData>,
) => createQueryKey("comicControllerGetAllStatuses", options);

/**
 * List all statuses
 */
export const comicControllerGetAllStatusesOptions = (
  options?: Options<ComicControllerGetAllStatusesData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await comicControllerGetAllStatuses({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: comicControllerGetAllStatusesQueryKey(options),
  });
};

export const comicControllerCreateStatusQueryKey = (
  options: Options<ComicControllerCreateStatusData>,
) => createQueryKey("comicControllerCreateStatus", options);

/**
 * Create a new status
 */
export const comicControllerCreateStatusOptions = (
  options: Options<ComicControllerCreateStatusData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await comicControllerCreateStatus({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: comicControllerCreateStatusQueryKey(options),
  });
};

/**
 * Create a new status
 */
export const comicControllerCreateStatusMutation = (
  options?: Partial<Options<ComicControllerCreateStatusData>>,
): UseMutationOptions<
  ComicControllerCreateStatusResponse,
  ComicControllerCreateStatusError,
  Options<ComicControllerCreateStatusData>
> => {
  const mutationOptions: UseMutationOptions<
    ComicControllerCreateStatusResponse,
    ComicControllerCreateStatusError,
    Options<ComicControllerCreateStatusData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await comicControllerCreateStatus({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Delete a status
 */
export const comicControllerDeleteStatusMutation = (
  options?: Partial<Options<ComicControllerDeleteStatusData>>,
): UseMutationOptions<
  unknown,
  ComicControllerDeleteStatusError,
  Options<ComicControllerDeleteStatusData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    ComicControllerDeleteStatusError,
    Options<ComicControllerDeleteStatusData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await comicControllerDeleteStatus({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Update status
 */
export const comicControllerUpdateStatusMutation = (
  options?: Partial<Options<ComicControllerUpdateStatusData>>,
): UseMutationOptions<
  ComicControllerUpdateStatusResponse,
  ComicControllerUpdateStatusError,
  Options<ComicControllerUpdateStatusData>
> => {
  const mutationOptions: UseMutationOptions<
    ComicControllerUpdateStatusResponse,
    ComicControllerUpdateStatusError,
    Options<ComicControllerUpdateStatusData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await comicControllerUpdateStatus({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const chapterControllerFindAllChaptersQueryKey = (
  options: Options<ChapterControllerFindAllChaptersData>,
) => createQueryKey("chapterControllerFindAllChapters", options);

/**
 * List chapters with offset pagination
 */
export const chapterControllerFindAllChaptersOptions = (
  options: Options<ChapterControllerFindAllChaptersData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await chapterControllerFindAllChapters({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: chapterControllerFindAllChaptersQueryKey(options),
  });
};

export const chapterControllerFindAllChaptersInfiniteQueryKey = (
  options: Options<ChapterControllerFindAllChaptersData>,
): QueryKey<Options<ChapterControllerFindAllChaptersData>> =>
  createQueryKey("chapterControllerFindAllChapters", options, true);

/**
 * List chapters with offset pagination
 */
export const chapterControllerFindAllChaptersInfiniteOptions = (
  options: Options<ChapterControllerFindAllChaptersData>,
) => {
  return infiniteQueryOptions<
    ChapterControllerFindAllChaptersResponse,
    ChapterControllerFindAllChaptersError,
    InfiniteData<ChapterControllerFindAllChaptersResponse>,
    QueryKey<Options<ChapterControllerFindAllChaptersData>>,
    | number
    | Pick<
        QueryKey<Options<ChapterControllerFindAllChaptersData>>[0],
        "body" | "headers" | "path" | "query"
      >
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<Options<ChapterControllerFindAllChaptersData>>[0],
          "body" | "headers" | "path" | "query"
        > =
          typeof pageParam === "object"
            ? pageParam
            : {
                query: {
                  page: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await chapterControllerFindAllChapters({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey: chapterControllerFindAllChaptersInfiniteQueryKey(options),
    },
  );
};

export const chapterControllerCreateChapterQueryKey = (
  options: Options<ChapterControllerCreateChapterData>,
) => createQueryKey("chapterControllerCreateChapter", options);

/**
 * Create a new chapter
 */
export const chapterControllerCreateChapterOptions = (
  options: Options<ChapterControllerCreateChapterData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await chapterControllerCreateChapter({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: chapterControllerCreateChapterQueryKey(options),
  });
};

/**
 * Create a new chapter
 */
export const chapterControllerCreateChapterMutation = (
  options?: Partial<Options<ChapterControllerCreateChapterData>>,
): UseMutationOptions<
  ChapterControllerCreateChapterResponse,
  ChapterControllerCreateChapterError,
  Options<ChapterControllerCreateChapterData>
> => {
  const mutationOptions: UseMutationOptions<
    ChapterControllerCreateChapterResponse,
    ChapterControllerCreateChapterError,
    Options<ChapterControllerCreateChapterData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await chapterControllerCreateChapter({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const chapterControllerFindChapterBySlugQueryKey = (
  options: Options<ChapterControllerFindChapterBySlugData>,
) => createQueryKey("chapterControllerFindChapterBySlug", options);

/**
 * Find chapter by slug
 */
export const chapterControllerFindChapterBySlugOptions = (
  options: Options<ChapterControllerFindChapterBySlugData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await chapterControllerFindChapterBySlug({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: chapterControllerFindChapterBySlugQueryKey(options),
  });
};

/**
 * Delete a chapter
 */
export const chapterControllerDeleteChapterMutation = (
  options?: Partial<Options<ChapterControllerDeleteChapterData>>,
): UseMutationOptions<
  unknown,
  ChapterControllerDeleteChapterError,
  Options<ChapterControllerDeleteChapterData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    ChapterControllerDeleteChapterError,
    Options<ChapterControllerDeleteChapterData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await chapterControllerDeleteChapter({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Update chapter
 */
export const chapterControllerUpdateChapterMutation = (
  options?: Partial<Options<ChapterControllerUpdateChapterData>>,
): UseMutationOptions<
  ChapterControllerUpdateChapterResponse,
  ChapterControllerUpdateChapterError,
  Options<ChapterControllerUpdateChapterData>
> => {
  const mutationOptions: UseMutationOptions<
    ChapterControllerUpdateChapterResponse,
    ChapterControllerUpdateChapterError,
    Options<ChapterControllerUpdateChapterData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await chapterControllerUpdateChapter({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const userTitleStateControllerFindAllUserTitleStatesQueryKey = (
  options?: Options<UserTitleStateControllerFindAllUserTitleStatesData>,
) => createQueryKey("userTitleStateControllerFindAllUserTitleStates", options);

/**
 * Get current user title states
 */
export const userTitleStateControllerFindAllUserTitleStatesOptions = (
  options?: Options<UserTitleStateControllerFindAllUserTitleStatesData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await userTitleStateControllerFindAllUserTitleStates({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: userTitleStateControllerFindAllUserTitleStatesQueryKey(options),
  });
};

export const userTitleStateControllerCreateUserTitleStateQueryKey = (
  options: Options<UserTitleStateControllerCreateUserTitleStateData>,
) => createQueryKey("userTitleStateControllerCreateUserTitleState", options);

/**
 * Create or update user title state
 */
export const userTitleStateControllerCreateUserTitleStateOptions = (
  options: Options<UserTitleStateControllerCreateUserTitleStateData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await userTitleStateControllerCreateUserTitleState({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: userTitleStateControllerCreateUserTitleStateQueryKey(options),
  });
};

/**
 * Create or update user title state
 */
export const userTitleStateControllerCreateUserTitleStateMutation = (
  options?: Partial<Options<UserTitleStateControllerCreateUserTitleStateData>>,
): UseMutationOptions<
  UserTitleStateControllerCreateUserTitleStateResponse,
  UserTitleStateControllerCreateUserTitleStateError,
  Options<UserTitleStateControllerCreateUserTitleStateData>
> => {
  const mutationOptions: UseMutationOptions<
    UserTitleStateControllerCreateUserTitleStateResponse,
    UserTitleStateControllerCreateUserTitleStateError,
    Options<UserTitleStateControllerCreateUserTitleStateData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await userTitleStateControllerCreateUserTitleState({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const userTitleStateControllerGetUserBookmarksQueryKey = (
  options?: Options<UserTitleStateControllerGetUserBookmarksData>,
) => createQueryKey("userTitleStateControllerGetUserBookmarks", options);

/**
 * Get current user bookmarks
 */
export const userTitleStateControllerGetUserBookmarksOptions = (
  options?: Options<UserTitleStateControllerGetUserBookmarksData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await userTitleStateControllerGetUserBookmarks({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: userTitleStateControllerGetUserBookmarksQueryKey(options),
  });
};

/**
 * Delete user title state
 */
export const userTitleStateControllerDeleteUserTitleStateMutation = (
  options?: Partial<Options<UserTitleStateControllerDeleteUserTitleStateData>>,
): UseMutationOptions<
  unknown,
  UserTitleStateControllerDeleteUserTitleStateError,
  Options<UserTitleStateControllerDeleteUserTitleStateData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    UserTitleStateControllerDeleteUserTitleStateError,
    Options<UserTitleStateControllerDeleteUserTitleStateData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await userTitleStateControllerDeleteUserTitleState({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const userTitleStateControllerFindUserTitleStateQueryKey = (
  options: Options<UserTitleStateControllerFindUserTitleStateData>,
) => createQueryKey("userTitleStateControllerFindUserTitleState", options);

/**
 * Find user title state by id
 */
export const userTitleStateControllerFindUserTitleStateOptions = (
  options: Options<UserTitleStateControllerFindUserTitleStateData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await userTitleStateControllerFindUserTitleState({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: userTitleStateControllerFindUserTitleStateQueryKey(options),
  });
};

/**
 * Update user title state
 */
export const userTitleStateControllerUpdateUserTitleStateMutation = (
  options?: Partial<Options<UserTitleStateControllerUpdateUserTitleStateData>>,
): UseMutationOptions<
  UserTitleStateControllerUpdateUserTitleStateResponse,
  UserTitleStateControllerUpdateUserTitleStateError,
  Options<UserTitleStateControllerUpdateUserTitleStateData>
> => {
  const mutationOptions: UseMutationOptions<
    UserTitleStateControllerUpdateUserTitleStateResponse,
    UserTitleStateControllerUpdateUserTitleStateError,
    Options<UserTitleStateControllerUpdateUserTitleStateData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await userTitleStateControllerUpdateUserTitleState({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const userTitleStateControllerGetUserTitleStateQueryKey = (
  options: Options<UserTitleStateControllerGetUserTitleStateData>,
) => createQueryKey("userTitleStateControllerGetUserTitleState", options);

/**
 * Get user state for specific comic
 */
export const userTitleStateControllerGetUserTitleStateOptions = (
  options: Options<UserTitleStateControllerGetUserTitleStateData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await userTitleStateControllerGetUserTitleState({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: userTitleStateControllerGetUserTitleStateQueryKey(options),
  });
};

export const userTitleStateControllerUpdateReadingProgressQueryKey = (
  options: Options<UserTitleStateControllerUpdateReadingProgressData>,
) => createQueryKey("userTitleStateControllerUpdateReadingProgress", options);

/**
 * Update reading progress for a comic
 */
export const userTitleStateControllerUpdateReadingProgressOptions = (
  options: Options<UserTitleStateControllerUpdateReadingProgressData>,
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await userTitleStateControllerUpdateReadingProgress({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: userTitleStateControllerUpdateReadingProgressQueryKey(options),
  });
};

export const userTitleStateControllerUpdateReadingProgressInfiniteQueryKey = (
  options: Options<UserTitleStateControllerUpdateReadingProgressData>,
): QueryKey<Options<UserTitleStateControllerUpdateReadingProgressData>> =>
  createQueryKey(
    "userTitleStateControllerUpdateReadingProgress",
    options,
    true,
  );

/**
 * Update reading progress for a comic
 */
export const userTitleStateControllerUpdateReadingProgressInfiniteOptions = (
  options: Options<UserTitleStateControllerUpdateReadingProgressData>,
) => {
  return infiniteQueryOptions<
    UserTitleStateControllerUpdateReadingProgressResponse,
    UserTitleStateControllerUpdateReadingProgressError,
    InfiniteData<UserTitleStateControllerUpdateReadingProgressResponse>,
    QueryKey<Options<UserTitleStateControllerUpdateReadingProgressData>>,
    | number
    | Pick<
        QueryKey<Options<UserTitleStateControllerUpdateReadingProgressData>>[0],
        "body" | "headers" | "path" | "query"
      >
  >(
    // @ts-ignore
    {
      queryFn: async ({ pageParam, queryKey, signal }) => {
        // @ts-ignore
        const page: Pick<
          QueryKey<
            Options<UserTitleStateControllerUpdateReadingProgressData>
          >[0],
          "body" | "headers" | "path" | "query"
        > =
          typeof pageParam === "object"
            ? pageParam
            : {
                path: {
                  cursor: pageParam,
                },
              };
        const params = createInfiniteParams(queryKey, page);
        const { data } = await userTitleStateControllerUpdateReadingProgress({
          ...options,
          ...params,
          signal,
          throwOnError: true,
        });
        return data;
      },
      queryKey:
        userTitleStateControllerUpdateReadingProgressInfiniteQueryKey(options),
    },
  );
};

/**
 * Update reading progress for a comic
 */
export const userTitleStateControllerUpdateReadingProgressMutation = (
  options?: Partial<Options<UserTitleStateControllerUpdateReadingProgressData>>,
): UseMutationOptions<
  UserTitleStateControllerUpdateReadingProgressResponse,
  UserTitleStateControllerUpdateReadingProgressError,
  Options<UserTitleStateControllerUpdateReadingProgressData>
> => {
  const mutationOptions: UseMutationOptions<
    UserTitleStateControllerUpdateReadingProgressResponse,
    UserTitleStateControllerUpdateReadingProgressError,
    Options<UserTitleStateControllerUpdateReadingProgressData>
  > = {
    mutationFn: async localOptions => {
      const { data } = await userTitleStateControllerUpdateReadingProgress({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};
